.. _glossary:

Glossary
========

.. glossary::
   :sorted:

   OTP Value
        A one-time password, which is generated by some mathematical algorithm, usually HMAC,
        based on a seed. The term OTP value is used frequently by privacyIDEA to distinguish
        the changing value from the :term:`OTP PIN`.
        In terms of two factor authentication the OTP Value is actually the 2nd factor,
        the possion factor, since it is usually only possible to calculage, if the user
        is in the possession of the smartphone app or a hardware token. The OTP Value is calculated
        using the secret cryptographic :term:`Seed`.

   OTP PIN
        The OTP PIN is the secret password with which the user authenticates against privacyIDEA.
        The policy action :ref:`otppin_policy` sets the type of password. With this
        password privacyIDEA will identify the tokens for which further actions are taken
        (trigger a challenge or check a given :term:`OTP Value`).
        In terms of two factor authentication the OTP PIN is the first factor, the knowledge.

   Seed
        The seed is a cryptographic secret which is shared between the privacyIDEA server and the client
        like the smartphone app or a hardware token.
        One-time passwords are calculated based on the seed.

   Count
   Counter
        The token property ``count`` in privacyIDEA is used to calculate the :term:`OTP Value`
        using the HMAC-type algorithms HOTP or TOTP.

   WebUI
        privacyIDEA comes with a web-based user interface which is used to manage and
        configure the privacyIDEA server.

        It is also used a self-service portal for the average user, who manages his own tokens.
        This section gives an overview on the interface and links the respective sections in the documentation.

        * :ref:`dashboard`
        * :ref:`tokensview`
        * :ref:`usersview`
        * :ref:`machines`
        * :ref:`config`
        * :ref:`audit`
        * :ref:`components`

   Time Step
        A TOTP token can have a timestep of 30/60 seconds. It can still be used, if this 30/60 seconds are over.
        Technically the timestep is the divider by which the seconds since 1.1.1970 (unix system time)
        are devided to calculate the OTP value.

        The ``timestep`` is different to the :term:`Time Window`.

   Time Window
        Timewindow in which the given OTP value is valid for authentication.
        ``Timestep and timewindow`` are completely similar to the ``counter and window`` of HOTP tokens.

   Revoked Token
        Tokens can be ``revoked``. Usually this means the token is ``disabled and locked``. A locked token can
        not be modified anymore. It can only be deleted. Certain token types like certificate may
        define special actions when revoking a token.

   Orphaned Token
        An orphaned token means, that it has a user assigned, but the user does not exist in the
        user store (anymore).

   Disabled Token
        Tokens can be ``disabled``. Disabled tokens still belong to the assigned user but those tokens
        can not be used to authenticate. ``Disabled tokens can be enabled again``.

   Resolver(UserId)
        UserIdResolvers are connectors to those user stores, the locations,
        where the users are managed. Nowadays this can be LDAP directories or
        especially Active Directory, some times FreeIPA or the Redhat 389 service.
        But classically users are also located in files like ``/etc/passwd`` on
        standalone unix systems. Web services often use SQL databases as
        user store.

        Today with many more online cloud services SCIM is also an uprising
        protocol to access userstores.

        privacyIDEA already comes with :ref:`useridresolvers` to talk to all these
        user stores:

        * :ref:`flatfile_resolver`
        * :ref:`ldap_resolver`
        * :ref:`sql_resolver`
        * :ref:`scim_resolver`
        * :ref:`http_resolver`

   Resolver(Machine)
        Machine Resolvers are used to find machines in directories like LDAP,
        Active Directory, puppet, salt, or the /etc/hosts file.

        The idea is for users to be able to authenticate on those client machines.
        Not in all cases an online authentication request is possible,
        so that authentication items can be passed to those client machines.

        In addition you need to define, which application on the client machine
        the user should authenticate to.
        Different application require different authentication items.

        Therefore privacyIDEA can define application types.
        At the moment privacyIDEA knows the application
        ``luks``, ``offline`` and ``ssh``.

   Tokeninfo
        The table “tokeninfo” is used to store additional, long information that is
        specific to the :ref:`tokentypes`. E.g. the tokentype “TOTP” has additional entries
        in the tokeninfo table for “timeStep” and “timeWindow”, which are stored in the
        column “Key” and “Value”.

        The ``tokeninfo`` is reference by the foreign key to the “token” table.

        Token info can be viewed and partially edited in the GUI. In addition, the
        Token-Janitor can be used to output token info, filter for tokens that have
        specific tokeninfo and set user-defined tokeninfos.

   Token
        All token information is stored in an SQL database, while you may choose, which database
        you want to use. privacyIDEA uses SQLAlchemy to map the database to internal objects.
        Thus you may choose to run privacyIDEA with SQLite, MySQL, PostgreSQL, Oracle,
        DB2 or other database.

        PrivacyIDEA supports a great variety of different token types.
        They each have different requirements concerning configuration and how
        the authentication works. This chapter explains the authentication modes, lists the
        supported hardware and software tokens and explains how the token types can be used
        with privacyIDEA.
        Tools which facilitate and automate token enrollment are found in :ref:`enrollment_tools`.

        * :ref:`authentication_modes`
        * :ref:`supported_tokens`
        * :ref:`tokentypes`

   Audit
        The systems provides a sophisticated audit log, that can be viewed in the WebUI.

        The Audit log lists all events the server registers.

        .. figure:: /audit/auditlog.png
           :width: 500

           *Audit Log*

        privacyIDEA comes with a default SQL audit module (see :ref:`code_audit`).

        Starting with version 3.2 privacyIDEA also provides a :ref:`logger_audit` and
        a :ref:`container_audit` which can be used to send privacyIDEA audit log messages
        to services like splunk or logstash.

   Tokenowner
        The owner of a token is the user for whom the token was rolled out.

   FailCount
   MaxFail
        The FailCount count the number of failed login attempts.

        If the login fail counter reaches the ``MaxFail`` the user can not login
        with this token anymore.

        The administrator or help desk user can select those tokens and
        click the button ``reset failcounter`` to reset the fail counter to zero.
        The tokens can be used for authentication again.

   SplitAtSign
        ``splitAtSign`` defines if the username like *user@company*
        given during authentication should
        be split into the loginname *user* and the realm name *company*.
        In most cases this is the wanted behaviour so this is enabled by default.

        But given your users log in with email addresses like *user@gmail.com* and
        *otheruser@outlook.com* you probably do not want to split.

        How a user is related to a realm is described here: :ref:`relate_realm`

        This option also affects the login via the :ref:`rest_auth`
